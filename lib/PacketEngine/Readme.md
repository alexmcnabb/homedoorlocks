# Packet Engine Overview
Messages can be sent either way. The message contains a device ID, a rolling code, and a payload XORed with part of the rolling code. The rolling code is generated by repeatidly hashing the prevous value stored in EEPROM. The base station stores a prevous hash for each remote, and will attempt to preform the hashing function several times in case some transmissions are missed. 

The system can be compiled into remote or base station mode as set by a compile flag. A base station can talk to multiple remote devices, but a remote is only paired to one base station.

Run generate_device_keys.py {device_id} to generate new base hash and hash token in device_keys.h. When adding more devices, add them to the lower section of device_keys.h. To resync a device, delete the keys from device_keys.h and rerun generate_device_keys.py. At bootup, we compare the hash token with the value in eeprom. If they're different, overwrite the existing hash in eeprom.

At some point in the future if there's buttons onboard you might be able to dynamically resync tokens and stuff.

Currently we're using 17 byte messages, 1 byte device_id, 4 byte payload, and 12 bytes of hash. The first 16 bytes of the 32 byte hash are sent in the message (the first four are XORed with the payload) and the second 16 bytes make up the secret part of the internal state.

There's two hashes. The first handles messages from the remote to the base station, and the second handles messages from the base station to the remote. They're written from device_keys.h as one big 64 byte block but used as two 32 byte hashes.

Requirements for build
	For a remote build, the active device id should be defined as DEVICE_ID. Set this by defining it in platformio.ini:
		build_flags = -DDEVICE_ID 1
	If this isn't defined, it's assumed to be operating as the base station


Security wise, the fact that both the base hashes and the code for the actual deadbolt is stored in the source code isn't great.